use syn::{parse_macro_input, DeriveInput, Error, Type};
use syn::{Field, Data, Fields, DataStruct, Generics};
use proc_macro2::{Ident, TokenStream};
use quote::{format_ident, quote_spanned, quote};
use syn::{Result, Token};
use syn::parse::{ParseStream};
use quote::ToTokens;


pub(crate) fn derive_expand_impl(ident: Ident,
                                 data: Data,
                                 generics: Generics) -> syn::Result<TokenStream> {
    let fields: Vec<_> = match &data {
        Data::Struct(DataStruct { fields, .. }) => match fields {
            Fields::Named(named) => named.named.clone(),
            Fields::Unit => Default::default(),
            _ => {
                return Ok(quote_spanned! {
                    ident.span() => compile_error!("you can only derive Inject on structs with named fields or empty structs");
                });
            }
        },
        _ => {
            return Ok(quote_spanned! {
                ident.span() => compile_error!("you can only derive Inject on structs");
            });
        }
    }.into_iter()
        .collect();

    let fields: Vec<TokenStream> = fields.iter()
        .filter(|x| !ignore_expansion(x))
        .map(|field| {
            let ident = format_ident!("{}", field.ident.as_ref().unwrap());
            let name = quote!( #ident );
            name
        })
        .collect::<Vec<_>>();

    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();


    if fields.is_empty() {
        return Ok(quote!(
        #[automatically_derived]
        impl #impl_generics mydi::expander::ComponentExpander for #ident #ty_generics #where_clause {
            fn expand<INJECTION_BINDER_TYPE: Clone + 'static>(self, injector: InjectionBinder<INJECTION_BINDER_TYPE>) -> InjectionBinder<INJECTION_BINDER_TYPE>  {
                injector
            }
        }
    ));
    }

    Ok(quote!(

        #[automatically_derived]
        impl #impl_generics mydi::expander::ComponentExpander for #ident #ty_generics #where_clause {
            fn expand<INJECTION_BINDER_TYPE: Clone + 'static>(self, injector: InjectionBinder<INJECTION_BINDER_TYPE>) -> InjectionBinder<INJECTION_BINDER_TYPE>  {
                let Self {#( #fields),* , .. } = self;
                injector
                  #(.instance(#fields))*
            }

        }

    ))
}


// generated by chat gpt
fn ignore_expansion(field: &Field) -> bool {
    for attribute in &field.attrs {
        if attribute.path.is_ident("ignore_expansion") ||
            attribute.path.is_ident("mydi::ignore_expansion") {
            return true;
        }
    }

    false
}
